<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>My Digital World</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; } canvas { display: block; }
        #bg-video { position: fixed; top: 50%; left: 50%; min-width: 100%; min-height: 100%; width: auto; height: auto; z-index: -100; transform: translateX(-50%) translateY(-50%); background-size: cover; }
        #css-renderer { position: fixed; top: 0; left: 0; pointer-events: none; } .css-object { pointer-events: auto; }
        #ui-container { position: fixed; top: 0; left: 0; width: 100%; color: white; font-family: monospace; padding: 20px; z-index: 100; pointer-events: none; text-shadow: 0 0 5px #00ffff, 0 0 8px #00ffff; }
        #game-info { display: flex; gap: 30px; font-size: 24px; }
        #message-box { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.7); color: white; padding: 40px; border: 1px solid #00ffff; border-radius: 8px; text-align: center; font-size: 32px; display: none; z-index: 200; text-shadow: 0 0 5px #00ffff; }
        #message-box button { font-family: monospace; font-size: 20px; padding: 12px 24px; margin-top: 20px; cursor: pointer; pointer-events: all; background: #111; color: #00ffff; border: 1px solid #00ffff; }
        #start-prompt { position: fixed; inset: 0; background: rgba(0,0,0,0.8); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 28px; z-index: 999; cursor: pointer; text-shadow: 0 0 8px #00ffff; }
        #npc-dialogue { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 15px 25px; border-radius: 10px; font-size: 18px; max-width: 80%; text-align: center; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 150; border: 1px solid #d946ef; text-shadow: 0 0 4px #d946ef; }
        #npc-dialogue.show { opacity: 1; }
    </style>
</head>
<body>
    <div id="ui-container"><div id="game-info"><div id="score">Score: 0</div><div id="lives" data-initial-lives="3">Lives: 3</div></div></div>
    <div id="message-box"><h2 id="message-title"></h2><p id="message-text"></p><button onclick="location.reload()">Re-initialize</button></div>
    <div id="start-prompt"><h1>// Click to Initialize</h1><p style="font-size: 16px;">(Mouse and Keyboard required)</p><p style="font-size: 12px; margin-top: 24px; color: #7d8590;">Note: If loading fails, files must be served from a web server.</p></div><div id="css-renderer"></div><div id="npc-dialogue"></div>
    <script type="importmap">{"imports": {"three": "https://unpkg.com/three@0.157.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"}}</script>
    <script type="module">
        import * as THREE from 'three'; 
        import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';
        
        
            function runGame(config) {
                let scene, camera, renderer, cssRenderer, player, playerVisual, playerPhysicsBody, clock, listener, composer;
                let controls = { forward: false, backward: false, left: false, right: false, jump: false };
                let playerVelocity = new THREE.Vector3();
                let onGround = false;
                let audiosToPlay = [], videosToPlay = [];
                let cameraYaw, cameraPitch;
                let cameraOffset = new THREE.Vector3(0, 2, config.controls.cameraDistance);
                let gameState = { score: 0, lives: config.rules.lives, gameOver: false, gameWon: false, lastPlatformId: -1, playerState: 'idle' };
                const staticPlatforms = [], movingPlatforms = [], jumpPads = [], phasingPlatforms = [], checkpoints = [], enemies = [], collectibles = [], hazards = [], mediaObjects = [];
                let playerPhysicsBox, enemyBoxes = [], collectibleBoxes = [], hazardBoxes = [];
                let dialogueTimeout;
                let atmosphereVideo;
                let currentRespawnPoint = new THREE.Vector3(0, config.rules.respawnY, 0);
                const ACTIVE_CHECKPOINT_COLOR = new THREE.Color(0x238636);

                function init() {
                    document.getElementById('lives').innerText = 'Lives: ' + config.rules.lives;
                    scene = new THREE.Scene(); 
                    let rendererConfig = { antialias: true, stencil: true };

                    switch(config.world.atmosphereType) {
                        case 'IMAGE': if (config.world.atmosphereMediaContent) { const texture = new THREE.TextureLoader().load(config.world.atmosphereMediaContent, () => { texture.mapping = THREE.EquirectangularReflectionMapping; texture.colorSpace = THREE.SRGBColorSpace; scene.background = texture; }); } else { scene.background = new THREE.Color(config.world.bgColor); } break;
                        case 'VIDEO': if (config.world.atmosphereMediaContent) { atmosphereVideo = document.createElement('video'); atmosphereVideo.id = 'bg-video'; atmosphereVideo.src = config.world.atmosphereMediaContent; atmosphereVideo.loop = true; atmosphereVideo.muted = true; atmosphereVideo.playsInline = true; document.body.prepend(atmosphereVideo); rendererConfig.alpha = true; } else { scene.background = new THREE.Color(config.world.bgColor); } break;
                        default: scene.background = new THREE.Color(config.world.bgColor); scene.fog = new THREE.Fog(config.world.fogColor, 1, 1 / (config.world.fogDensity || 0.001)); break;
                    }

                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); cameraYaw = new THREE.Object3D(); cameraPitch = new THREE.Object3D(); cameraYaw.add(cameraPitch); cameraPitch.add(camera); scene.add(cameraYaw); camera.position.copy(cameraOffset); renderer = new THREE.WebGLRenderer(rendererConfig); if(rendererConfig.alpha) renderer.setClearColor(0x000000, 0); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); cssRenderer = new CSS3DRenderer(); cssRenderer.setSize(window.innerWidth, window.innerHeight); document.getElementById('css-renderer').appendChild(cssRenderer.domElement); clock = new THREE.Clock(); listener = new THREE.AudioListener(); camera.add(listener); const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight); const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(5, 10, 7); scene.add(dirLight); 
                    
                    player = new THREE.Object3D();
                    player.position.copy(currentRespawnPoint);
                    scene.add(player);
                    const playerPhysicsGeo = new THREE.CapsuleGeometry(config.player.body.radius, config.player.body.height - (config.player.body.radius * 2), 4, 16);
                    playerPhysicsBody = new THREE.Mesh(playerPhysicsGeo, new THREE.MeshBasicMaterial({ visible: false }));
                    player.add(playerPhysicsBody);

                    const appearance = config.player.appearanceType;
                    const loader = new THREE.TextureLoader();
                    if (appearance === 'ANIMATED_SPRITE') {
                        player.userData.textures = {};
                        const idleTexUrl = config.player.spriteKeys.idle;
                        const walkTexUrl = config.player.spriteKeys.walk || idleTexUrl;
                        const jumpTexUrl = config.player.spriteKeys.jump || walkTexUrl;

                        const spriteMat = new THREE.SpriteMaterial({ map: null, transparent: true });
                        playerVisual = new THREE.Sprite(spriteMat);
                        const h = config.player.body.height;
                        playerVisual.scale.set(h, h, 1); // Default scale, corrected on texture load

                        if (idleTexUrl) {
                            loader.load(idleTexUrl, (texture) => {
                                player.userData.textures.idle = texture;
                                if (!playerVisual.material.map) { // Set only if no texture is set yet
                                    playerVisual.material.map = texture;
                                    const aspect = texture.image ? (texture.image.width / texture.image.height) : 1;
                                    playerVisual.scale.set(h * aspect, h, 1);
                                }
                            });
                        }
                        if (walkTexUrl) player.userData.textures.walk = loader.load(walkTexUrl);
                        if (jumpTexUrl) player.userData.textures.jump = loader.load(jumpTexUrl);

                    } else { // COLOR or TEXTURED_BLOCKY
                        playerVisual = new THREE.Group();
                        playerVisual.userData.parts = {};
                        const p = config.player;
                        const isTextured = appearance === 'TEXTURED_BLOCKY';

                        const createMaterial = (partName) => {
                            const key = isTextured ? p.textureKeys[partName] : null;
                            const mat = new THREE.MeshStandardMaterial({ color: isTextured ? 0xffffff : p.color });
                            if(key) mat.map = loader.load(key);
                            return mat;
                        };
                        
                        const faceKeys = ['headRight', 'headLeft', 'headTop', 'headBottom', 'headFront', 'headBack'];
                        const headMats = faceKeys.map(key => createMaterial(key));
                        
                        const torso = new THREE.Mesh(new THREE.BoxGeometry(p.bodyParts.torso.w, p.bodyParts.torso.h, p.bodyParts.torso.d), createMaterial('torso'));
                        const head = new THREE.Mesh(new THREE.BoxGeometry(p.bodyParts.head.s,p.bodyParts.head.s,p.bodyParts.head.s), headMats);
                        head.position.y = p.bodyParts.torso.h / 2 + p.bodyParts.head.s / 2;
                        
                        const limbGeo = new THREE.BoxGeometry(p.bodyParts.limbs.w, p.bodyParts.limbs.h, p.bodyParts.limbs.w);
                        const armL = new THREE.Mesh(limbGeo, createMaterial('armL'));
                        armL.position.set(-(p.bodyParts.torso.w/2 + p.bodyParts.limbs.w/2), 0, 0);
                        const armR = new THREE.Mesh(limbGeo, createMaterial('armR'));
                        armR.position.x = (p.bodyParts.torso.w/2 + p.bodyParts.limbs.w/2);
                        const legL = new THREE.Mesh(limbGeo, createMaterial('legL'));
                        legL.position.set(-(p.bodyParts.torso.w/4), -(p.bodyParts.torso.h/2), 0);
                        const legR = new THREE.Mesh(limbGeo, createMaterial('legR'));
                        legR.position.set((p.bodyParts.torso.w/4), -(p.bodyParts.torso.h/2), 0);

                        playerVisual.add(torso, head, armL, armR, legL, legR);
                        playerVisual.userData.parts = { torso, head, armL, armR, legL, legR };
                    }
                    player.add(playerVisual);
                    playerPhysicsBox = new THREE.Box3();

                    composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera));
                    if(config.world.effects.bloom) { composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), config.world.effects.bloomStrength, 0.4, config.world.effects.bloomThreshold)); }
                    if(config.world.effects.vignette) { composer.addPass(new ShaderPass({ uniforms: { tDiffuse: { value: null }, darkness: { value: config.world.effects.vignetteDarkness } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: `uniform sampler2D tDiffuse; uniform float darkness; varying vec2 vUv; void main() { vec2 uv = vUv; float d = distance(uv, vec2(0.5)); vec4 color = texture2D(tDiffuse, uv); gl_FragColor = vec4(color.rgb * (1.0 - d * darkness), color.a);}` })); }
                    if(config.world.effects.pixelate) { composer.addPass(new ShaderPass({ uniforms: { tDiffuse: { value: null }, resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }, pixelSize: { value: config.world.effects.pixelSize } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}`, fragmentShader: `uniform sampler2D tDiffuse; uniform vec2 resolution; uniform float pixelSize; varying vec2 vUv; void main() { vec2 uv = floor( vUv * resolution / pixelSize) * pixelSize / resolution; gl_FragColor = texture2D(tDiffuse, uv); }`})); }

                    config.objects.forEach(obj => { let mesh, box; const pos = new THREE.Vector3(obj.pos.x, obj.pos.y, obj.pos.z);
                        switch (obj.type) {
                            case 'PLATFORM': case 'NPC_PLATFORM': case 'HYPERLINK_PLATFORM': mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshLambertMaterial({ color: obj.color })); mesh.position.copy(pos); box = new THREE.Box3().setFromObject(mesh); staticPlatforms.push({mesh, box, config: obj}); break;
                            case 'MOVING_PLATFORM': mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshLambertMaterial({ color: obj.color })); mesh.position.copy(pos); box = new THREE.Box3().setFromObject(mesh); movingPlatforms.push({mesh, box, config: obj, lastPos: pos.clone()}); break;
                            case 'JUMP_PAD': mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshStandardMaterial({ color: obj.color, emissive: obj.color, emissiveIntensity: 0.5 })); mesh.position.copy(pos); box = new THREE.Box3().setFromObject(mesh); jumpPads.push({mesh, box, config: obj}); break;
                            case 'PHASING_PLATFORM': mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshLambertMaterial({ color: obj.color, transparent: true })); mesh.position.copy(pos); box = new THREE.Box3().setFromObject(mesh); phasingPlatforms.push({mesh, box, config: obj}); break;
                            case 'CHECKPOINT': mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2.5, 8), new THREE.MeshStandardMaterial({ color: obj.color, emissive: obj.color, emissiveIntensity: 0.5 })); mesh.position.copy(pos); box = new THREE.Box3().setFromObject(mesh); checkpoints.push({mesh, box, config: obj, activated: false}); break;
                            case 'MIRROR_PLATFORM': {
                                const group = new THREE.Group(); group.position.copy(pos);
                                const frame = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshLambertMaterial({ color: obj.color }));
                                const reflector = new Reflector(new THREE.PlaneGeometry(obj.scale.x, obj.scale.z), {
                                    clipBias: 0.003, textureWidth: window.innerWidth * window.devicePixelRatio, textureHeight: window.innerHeight * window.devicePixelRatio, color: 0x889999
                                });
                                reflector.position.y = obj.scale.y / 2 + 0.01;
                                reflector.rotation.x = -Math.PI / 2;
                                group.add(frame, reflector);
                                mesh = group;
                                box = new THREE.Box3();
                                box.setFromObject(frame, true); // Use the frame for collision
                                staticPlatforms.push({mesh: group, box, config: obj}); 
                                break;
                            }
                            case 'IMAGE_PLATFORM': if(!obj.mediaContent) break; const tex = new THREE.TextureLoader().load(obj.mediaContent); mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshLambertMaterial({ map: tex })); mesh.position.copy(pos); box = new THREE.Box3().setFromObject(mesh); staticPlatforms.push({mesh, box, config: obj}); break;
                            case 'VIDEO_PLATFORM': if(!obj.mediaContent) break; const video = document.createElement('video'); video.src = obj.mediaContent; video.loop = true; video.muted = true; video.playsInline = true; video.crossOrigin = 'anonymous'; const vidTex = new THREE.VideoTexture(video); mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshBasicMaterial({ map: vidTex })); videosToPlay.push(video); mesh.position.copy(pos); mesh.rotation.y = Math.PI / 2; box = new THREE.Box3().setFromObject(mesh); staticPlatforms.push({mesh, box, config: obj}); break;
                            case 'ENEMY': mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshLambertMaterial({ color: obj.color })); mesh.position.copy(pos); obj.direction = 1; obj.originX = obj.pos.x; enemies.push(mesh); box = new THREE.Box3().setFromObject(mesh); enemyBoxes.push(box); break;
                            case 'COLLECTIBLE': mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 0), new THREE.MeshStandardMaterial({ color: obj.color, emissive: obj.color })); mesh.position.copy(pos); collectibles.push(mesh); box = new THREE.Box3().setFromObject(mesh); collectibleBoxes.push(box); break;
                            case 'HAZARD': mesh = new THREE.Mesh(new THREE.BoxGeometry(obj.scale.x, obj.scale.y, obj.scale.z), new THREE.MeshLambertMaterial({ color: obj.color })); mesh.position.copy(pos); box = new THREE.Box3().setFromObject(mesh); hazardBoxes.push(box); break;
                            case 'MEDIA_IMAGE': if(!obj.mediaContent) break; const map = new THREE.TextureLoader().load(obj.mediaContent); mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: map, transparent: true })); mesh.scale.set(obj.size, obj.size, 1); mediaObjects.push(mesh); if (obj.collidable) { const center = new THREE.Vector3(obj.pos.x, obj.pos.y, obj.pos.z); const halfSize = new THREE.Vector3(obj.size / 2, obj.size / 2, 0.1); box = new THREE.Box3().setFromCenterAndSize(center, halfSize.multiplyScalar(2)); staticPlatforms.push({ mesh, box, config: obj }); } break;
                            case 'MEDIA_YOUTUBE': const videoIdMatch = obj.youtubeUrl.match(/(?:youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#\&\?]*).*/); const videoId = (videoIdMatch && videoIdMatch[1].length === 11) ? videoIdMatch[1] : null; if (videoId) { const embedUrl = `https://www.youtube-nocookie.com/embed/${videoId}?autoplay=1&loop=1&playlist=${videoId}&controls=0&mute=1`; const div = document.createElement('div'); div.className = 'css-object'; div.style.width = '640px'; div.style.height = '360px'; div.innerHTML = `<iframe src="${embedUrl}" style="width:100%;height:100%;border:0;" allow="autoplay; encrypted-media"></iframe>`; mesh = new CSS3DObject(div); const aspectRatio = 360 / 640; mesh.scale.set(0.01 * obj.size, 0.01 * obj.size * aspectRatio, 1); if (obj.collidable) { const center = new THREE.Vector3(obj.pos.x, obj.pos.y, obj.pos.z); const halfSize = new THREE.Vector3(obj.size / 2, (obj.size * aspectRatio) / 2, 0.1); box = new THREE.Box3().setFromCenterAndSize(center, halfSize.multiplyScalar(2)); staticPlatforms.push({ mesh, box, config: obj }); } } break;
                            case 'MEDIA_AUDIO': if(!obj.mediaContent) break; const audioHolder = new THREE.Object3D(); const pAudio = new THREE.PositionalAudio(listener); new THREE.AudioLoader().load(obj.mediaContent, (buffer) => { pAudio.setBuffer(buffer); pAudio.setRefDistance(obj.refDistance); pAudio.setLoop(obj.loop); pAudio.setVolume(obj.volume); audiosToPlay.push(pAudio); }); audioHolder.add(pAudio); mesh = audioHolder; break;
                        } if (mesh) { if(obj.type !== 'MIRROR_PLATFORM') mesh.position.copy(pos); mesh.userData = obj; scene.add(mesh); }
                    });
                    window.addEventListener('resize', onWindowResize); document.addEventListener('keydown', onKey); document.addEventListener('keyup', onKey); document.addEventListener('pointermove', onPointerMove); document.addEventListener('wheel', onMouseWheel); document.getElementById('start-prompt').addEventListener('click', startGame, { once: true });
                }
                function startGame() { document.getElementById('start-prompt').style.display = 'none'; document.body.requestPointerLock().catch(e => console.warn("Could not lock pointer:", e)); if (listener.context.state === 'suspended') listener.context.resume(); audiosToPlay.forEach(audio => audio.play()); videosToPlay.forEach(video => video.play().catch(e=>console.error("Video play failed:", e))); if(atmosphereVideo) atmosphereVideo.play().catch(e => console.error("Video play failed:", e)); animate(); }
                function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); cssRenderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
                function onPointerMove(event) { if (document.pointerLockElement !== document.body) return; const camSpeed = config.controls.cameraSpeed * 0.0002; const invert = config.controls.invertY ? 1 : -1; cameraYaw.rotation.y -= event.movementX * camSpeed; cameraPitch.rotation.x += event.movementY * camSpeed * invert; cameraPitch.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch.rotation.x)); }
                function onMouseWheel(event) { cameraOffset.z += event.deltaY * 0.01; cameraOffset.z = Math.max(3, Math.min(20, cameraOffset.z)); }
                function onKey(event) { const state = event.type === 'keydown'; const ctrl = config.controls; if (event.code === ctrl.forward) controls.forward = state; else if (event.code === ctrl.backward) controls.backward = state; else if (event.code === ctrl.left) controls.left = state; else if (event.code === ctrl.right) controls.right = state; else if (event.code === ctrl.jump) controls.jump = state; }
                function handlePlatformLanded(platform) { if (gameState.lastPlatformId === platform.config.id) return; gameState.lastPlatformId = platform.config.id; if (platform.config.type === 'NPC_PLATFORM') { const dialogueEl = document.getElementById('npc-dialogue'); dialogueEl.textContent = platform.config.npcText; dialogueEl.classList.add('show'); clearTimeout(dialogueTimeout); dialogueTimeout = setTimeout(() => dialogueEl.classList.remove('show'), 5000); if (platform.config.mediaContent) { const audio = new THREE.Audio(listener); new THREE.AudioLoader().load(platform.config.mediaContent, (buffer) => { audio.setBuffer(buffer); audio.play(); }); } } else if (platform.config.type === 'HYPERLINK_PLATFORM' && platform.config.hyperlinkUrl) { try { new URL(platform.config.hyperlinkUrl); showMessage('Redirecting...', `Opening: ${platform.config.hyperlinkUrl}`, false); setTimeout(() => { if(document.pointerLockElement) document.exitPointerLock(); window.open(platform.config.hyperlinkUrl, '_blank'); }, 2000); } catch(e) { console.error("Invalid URL:", platform.config.hyperlinkUrl); } } }
                function updatePlayer(delta, elapsedTime) {
                    const speed = config.player.speed;
                    const wasOnGround = onGround;
                    onGround = false;

                    playerVelocity.y -= config.world.gravity * delta;
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cameraYaw.quaternion).setY(0).normalize();
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(cameraYaw.quaternion).setY(0).normalize();
                    const moveDirection = new THREE.Vector3();
                    if (controls.forward) moveDirection.add(forward);
                    if (controls.backward) moveDirection.sub(forward);
                    if (controls.left) moveDirection.sub(right);
                    if (controls.right) moveDirection.add(right);
                    moveDirection.normalize();
                    
                    playerVelocity.x = moveDirection.x * speed;
                    playerVelocity.z = moveDirection.z * speed;
                    
                    if (controls.jump && wasOnGround) { playerVelocity.y = config.player.jumpForce; }
                    controls.jump = false;
                    
                    const allPlatforms = [...staticPlatforms, ...movingPlatforms, ...jumpPads, ...phasingPlatforms.filter(p => p.mesh.visible)];
                    const collisionSteps = 5;
                    const stepDelta = delta / collisionSteps;

                    for (let i = 0; i < collisionSteps; i++) {
                        const stepMovement = playerVelocity.clone().multiplyScalar(stepDelta);
                        player.position.add(stepMovement);
                        player.updateWorldMatrix(true, false);
                        playerPhysicsBox.setFromObject(playerPhysicsBody);

                        let groundCollisionThisStep = false;
                        
                        allPlatforms.forEach(p => {
                            if (p.config.type === 'MIRROR_PLATFORM') { p.box.setFromObject(p.mesh.children[0], true); } 
                            else if (p.mesh.isMesh) { p.box.setFromObject(p.mesh); }
                        });

                        for (const platform of allPlatforms) {
                            if (playerPhysicsBox.intersectsBox(platform.box)) {
                                const intersection = new THREE.Box3().copy(playerPhysicsBox).intersect(platform.box);
                                const penetration = new THREE.Vector3(
                                    intersection.max.x - intersection.min.x,
                                    intersection.max.y - intersection.min.y,
                                    intersection.max.z - intersection.min.z
                                );
                                
                                const playerCenter = playerPhysicsBox.getCenter(new THREE.Vector3());
                                const platformCenter = platform.box.getCenter(new THREE.Vector3());

                                if (penetration.y < penetration.x && penetration.y < penetration.z) { // Vertical collision
                                    if (playerCenter.y > platformCenter.y) { // Landed on top
                                        player.position.y += penetration.y;
                                        playerVelocity.y = 0;
                                        onGround = true;
                                        groundCollisionThisStep = true;
                                        if (gameState.lastPlatformId !== platform.config.id) {
                                            if (platform.config.type === 'JUMP_PAD') { playerVelocity.y = platform.config.bounceForce; }
                                            else { handlePlatformLanded(platform); }
                                        }
                                        gameState.lastPlatformId = platform.config.id;
                                    } else { // Hit ceiling
                                        player.position.y -= penetration.y;
                                        if (playerVelocity.y > 0) playerVelocity.y = 0;
                                    }
                                } else if (penetration.x < penetration.z) { // Horizontal X collision
                                    player.position.x += (playerCenter.x > platformCenter.x ? penetration.x : -penetration.x);
                                    playerVelocity.x = 0;
                                } else { // Horizontal Z collision
                                    player.position.z += (playerCenter.z > platformCenter.z ? penetration.z : -penetration.z);
                                    playerVelocity.z = 0;
                                }
                                
                                player.updateWorldMatrix(true, false);
                                playerPhysicsBox.setFromObject(playerPhysicsBody);
                            }
                        }
                        
                        if (groundCollisionThisStep && gameState.lastPlatformId !== -1) {
                            const lastPlat = movingPlatforms.find(p => p.config.id === gameState.lastPlatformId);
                            if(lastPlat) {
                                const platVelFrame = lastPlat.mesh.position.clone().sub(lastPlat.lastPos).divideScalar(delta).multiplyScalar(stepDelta);
                                player.position.add(platVelFrame);
                            }
                        }
                    }

                    if (!onGround) { gameState.lastPlatformId = -1; }
                    
                    cameraYaw.position.copy(player.position);
                    camera.position.lerp(cameraOffset, 0.1);
                    
                    let newState = 'idle';
                    if (!onGround) newState = 'jump'; else if (moveDirection.lengthSq() > 0.01) newState = 'walk';
                    if (newState !== gameState.playerState) {
                        gameState.playerState = newState;
                        if(config.player.appearanceType === 'ANIMATED_SPRITE') {
                            const newTex = player.userData.textures[newState] || player.userData.textures.walk || player.userData.textures.idle;
                            if(newTex) playerVisual.material.map = newTex;
                        }
                    }
                    if(config.player.appearanceType === 'COLOR' || config.player.appearanceType === 'TEXTURED_BLOCKY') {
                        const parts = playerVisual.userData.parts;
                        const anim = config.player.animation;
                        let currentSwing = 0; if (newState === 'walk') { currentSwing = Math.sin(elapsedTime * anim.walkSpeed) * anim.swingAngle; }
                        const lerpSpeed = delta * 10;
                        parts.armL.rotation.x += (currentSwing - parts.armL.rotation.x) * lerpSpeed;
                        parts.armR.rotation.x += (-currentSwing - parts.armR.rotation.x) * lerpSpeed;
                        parts.legL.rotation.x += (-currentSwing - parts.legL.rotation.x) * lerpSpeed;
                        parts.legR.rotation.x += (currentSwing - parts.legR.rotation.x) * lerpSpeed;
                        playerVisual.rotation.y += (cameraYaw.rotation.y - playerVisual.rotation.y) * lerpSpeed;
                    }
                }
                function checkInteractions() {
                     player.updateWorldMatrix(true, false); playerPhysicsBox.setFromObject(playerPhysicsBody);
                     for (let i = collectibles.length - 1; i >= 0; i--) { if(collectibles[i] && playerPhysicsBox.intersectsBox(collectibleBoxes[i])) { gameState.score += collectibles[i].userData.value; document.getElementById('score').innerText = 'Score: ' + gameState.score; scene.remove(collectibles[i]); collectibles.splice(i, 1); collectibleBoxes.splice(i, 1); } }
                     for (const cp of checkpoints) {
                        if (!cp.activated && playerPhysicsBox.intersectsBox(cp.box)) {
                            cp.activated = true;
                            currentRespawnPoint.copy(cp.mesh.position).add(new THREE.Vector3(0, 1, 0));
                            cp.mesh.material.color = ACTIVE_CHECKPOINT_COLOR;
                            cp.mesh.material.emissive = ACTIVE_CHECKPOINT_COLOR;
                        }
                     }
                     const allHazards = [...enemyBoxes, ...hazardBoxes]; for (const box of allHazards) { if (playerPhysicsBox.intersectsBox(box)) { loseLife(); return; } } if (player.position.y < -50) { loseLife(); }
                }
                function updateSceneObjects(delta, elapsedTime) {
                    enemies.forEach((enemy, i) => { const data = enemy.userData; enemy.position.x += 1.5 * data.direction * delta; if (enemy.position.x > data.originX + data.patrolRange || enemy.position.x < data.originX - data.patrolRange) { data.direction *= -1; } enemyBoxes[i].setFromObject(enemy); });
                    collectibles.forEach(c => { c.rotation.y += 1 * delta; });
                    mediaObjects.forEach(m => { if (m.isSprite) m.lookAt(camera.position); });
                    movingPlatforms.forEach(p => {
                        p.lastPos.copy(p.mesh.position);
                        const range = p.config.patrolRange;
                        const speed = p.config.speed / 5;
                        p.mesh.position[p.config.axis] = p.config.pos[p.config.axis] + Math.sin(elapsedTime * speed) * range;
                    });
                    phasingPlatforms.forEach(p => {
                        const cycle = p.config.onTime + p.config.offTime;
                        const timeInCycle = (elapsedTime + p.config.phase) % cycle;
                        p.mesh.visible = timeInCycle < p.config.onTime;
                    });
                }
                function loseLife() { gameState.lives--; document.getElementById('lives').innerText = 'Lives: ' + gameState.lives; if (gameState.lives <= 0) { gameState.gameOver = true; showMessage('Execution Halted', 'Final Score: ' + gameState.score); } else { player.position.copy(currentRespawnPoint); playerVelocity.set(0,0,0); } }
                function checkWinCondition() { if (!gameState.gameWon && gameState.score >= config.rules.winScore) { gameState.gameWon = true; showMessage('Execution Complete', 'Final Score: ' + gameState.score); } }
                function showMessage(title, text, showButton = true) { if(document.pointerLockElement) document.exitPointerLock(); document.getElementById('message-title').innerText = title; document.getElementById('message-text').innerText = text; document.getElementById('message-box').querySelector('button').style.display = showButton ? 'inline-block' : 'none'; document.getElementById('message-box').style.display = 'block'; }
                function animate() { if (gameState.gameOver || gameState.gameWon) return; requestAnimationFrame(animate); const delta = Math.min(clock.getDelta(), 0.1); const elapsedTime = clock.getElapsedTime(); updateSceneObjects(delta, elapsedTime); updatePlayer(delta, elapsedTime); checkInteractions(); checkWinCondition(); composer.render(); cssRenderer.render(scene, camera); }
                
                init();
            }
        
                (async () => {
                    let config;
                    try {
                        const response = await fetch('world.json');
                        if (!response.ok) throw new Error('Network response was not ok');
                        config = await response.json();
                    } catch (error) {
                        console.error('Failed to load world config:', error);
                        document.getElementById('start-prompt').innerHTML = '<h1>‚ùå Error</h1><p>Could not load world.json. This folder must be run from a web server.</p>';
                        return;
                    }
                    runGame(config);
                })();
                
    </script>
</body>
</html>